# -*- coding: utf-8 -*-
"""ë””ìŠ¤ì½”ë“œ ë´‡ ì½”ë“œ

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zn1Rizx14A4Ma2mf40QbpMcT7SUEtXrh
"""



import discord
import os
import openai
import re
from discord import app_commands
from discord.ext import commands

import time
import datetime

import random
import asyncio

import sqlite3

# db, ëŒ€í™”ê´€ë ¨ í•¨ìˆ˜, ë””ìŠ¤ì½”ë“œ ëª…ë ¹ì–´ëŠ” ë°‘ì— ì¶”ê°€í•´ë‘ 
class Nod:
    def __init__(self, item):
        self.item = item

a = Nod(1) #ëŒ€í™”ë°›ì„ë–„, a.itemì´ 1ì´ë©´ íšŒì˜ì‹œì‘, 0ì´ë©´ íšŒì˜ì¢…ë£Œí•¨. ì—¬ëŸ¬ê°€ì§€ ì‹œë„í•´ë´¤ëŠ”ë° ì´ê²Œ ê°€ì¥í™•ì‹¤í•¨..


def connection(a):
    # a = #íŒŒì¼ì´ë¦„
    try:
        con = sqlite3.connect(f'{os.getcwd()}/{a}.db') #ì—¬ê¸°ì—ì„œ íŒŒì¼ ê²½ë¡œë§Œ ë„£ì–´ì¤€ë‹¤ë©´ ì›í•˜ëŠ” ìœ„ì¹˜ì— ìƒì„±í• ìˆ˜ìˆìŒ (**ê²½ë¡œ**/íŒŒì¼ëª….db) ì´ëŸ°ì‹, ê²½ë¡œì„¤ì •ì€ ì•„ì§ ê²°ì •ì•ˆí•¨
        return con
    except:
        pass

def create_table(con):#í™˜ê²½ì„¤ì •, ì—¬ê¸°ì„œ ë‚ ì§œ ì„¤ì •ì´ ê¸°ë³¸ì ìœ¼ë¡œ ë“¤ì–´ê°. ë‚ ì§œê°€ í…Œì´ë¸”ì´ë¦„ì— ì í˜
    cusor_db = con.cursor()
    cusor_db.execute(f'CREATE TABLE ëŒ€í™”_í…Œì´ë¸”(id TEXT, name TEXT, input_data TEXT, date TEXT )')
    con.commit()

def insert_one(con, one_data): # ì‚½ì…
    cusor_db = con.cursor()
    cusor_db.execute(
        'INSERT INTO ëŒ€í™”_í…Œì´ë¸” VALUES (?, ?, ?, ?)',
        one_data
    )
    # í…Œì´ë¸”ì„ ë” ëŠ˜ë¦¬ê³ ì‹¶ë‹¤ë©´  ? ì¶”ê°€
    con.commit()

def receive_discord(message,i, Username):
    name = 'ë””ìŠ¤ì½”ë“œí…ŒìŠ¤íŠ¸' # íŒŒì¼ì´ë¦„ ê³ ì •ì€ ë‚˜ì¤‘ì— ìˆ˜ì •.
    con = connection(name)
    try:
        create_table(con)  # í•„ìˆ˜, í…Œì´ë¸” ë§Œë“¤ê¸°
    except:
        pass
    data = message
    user = Username
    x = dt.datetime.now()
    date = f'{x.hour}ì‹œ {x.minute}ë¶„ {x.second}ì´ˆ'
    one_data = (i, str(user), str(data), date)  # ì €ì¥í˜•ì‹
    insert_one(con, one_data)  # ëŒ€í™”ë°ì´í„° ì €ì¥

#

intents = discord.Intents.default()
intents.message_content = True

client = discord.Client(intents = intents)
bot = commands.Bot(command_prefix='!',intents = intents)






openai.api_key = openai_key

@client.event
async def on_ready(): #ì‹¤í–‰ ì¤€ë¹„ê°€ ë˜ë©´ ì¤€ë¹„ê°€ ë¨ì„ í‘œì‹œ
    print('We have logged in as {0.user}'.format(client))

@bot.event
async def on_connect():
    if bot.auto_sync_commands:
        await bot.sync_commands()
    print(f"{bot.user.name} connected.")


def create_image_embed(title: str, description: str, url: str):
    embed = discord.Embed(
        title=title,
        description=description,
    )
    embed.set_thumbnail(url=url)
    embed.set_image(url=url)
    return embed



@client.event
async def on_message(message):  #ë©”ì„¸ì§€ í™•ì¸
    if message.author == client.user:   #ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ ì‚¬ëŒì´ ë´‡ì´ë©´ ë¹ ì ¸ë‚˜ì˜¤ê¸°
        return
    text = message.content

    if text.startswith('image/'):    #íŠ¹ì • ë©”ì‹œì§€ë¥¼ ë³´ëƒˆì„ ë•Œ ë°˜ì‘
        prompt = text[6:]
        translate = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt + "Please translate the previous sentence into English and only print out the translated answer",
            max_tokens=500,
            temperature=0
        )
        print("Image prompt:", prompt)
        response = openai.Image.create(
            prompt='\n'.join([choice.text for choice in translate.choices]),
            n=1,
            size="256x256"
        )
        print(response)
        data: list = response['data']
        for index, image in enumerate(data):
            title = f"Image generated #{index + 1}"
            embed = create_image_embed(title, prompt, image['url'])
            await message.channel.send('', embed=embed)
        await message.channel.send(prompt)

    if text.startswith('vote/'):
        prompt = text[5:]
        vote_txt=prompt.split("/")
        await message.channel.send(vote_txt[0])
        for i in range(1,len(vote_txt)):
            choose = await message.channel.send(vote_txt[i])
            await choose.add_reaction('ğŸ‘')


    if text.startswith('ask/'):    #íŠ¹ì • ë©”ì‹œì§€ë¥¼ ë³´ëƒˆì„ ë•Œ ë°˜ì‘
        prompt = text[4:]
        bot_response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            max_tokens=500,
            temperature=0
        )
        print('bot response:', bot_response)
        print(message.author)
        bot_text = '\n'.join([choice.text for choice in bot_response.choices])
        await message.channel.send(bot_text)


    if text.startswith('alarm/'):  #ì•Œë¦¼ ê¸°ëŠ¥
        prompt = text[6:]
        time_lst = list(prompt.split("/"))            #time_lstëŠ” ì‹œê°„ì„ ë‹´ëŠ” ë¦¬ìŠ¤íŠ¸
        date=datetime.datetime(int(time_lst[0]),int(time_lst[1]),int(time_lst[2]),int(time_lst[3]),int(time_lst[4]))

        while True:
            curr_t = datetime.datetime.now()
            if date <= curr_t:
                bot_text = "<"+str(date)+">"
                await message.channel.send(bot_text)
                bot_text = "\"" + time_lst[-1] + "\"ì˜ ë‚´ìš©ì´ ì˜ˆì•½ ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
                await message.channel.send(bot_text)
                break
            time.sleep(1)

    #ê²½ë§ˆê¸°ëŠ¥
    if message.content.startswith('!race'):
        await race(message)



    # íšŒì˜ëŒ€í™” ë°›ê¸°
    if text == 'íšŒì˜ì¢…ë£Œ':
        a.item = 0
        print('íšŒì˜ ì¢…ë£Œì¤‘ì´ì—ìš”')
    if a.item == 1:
        print('ì œëŒ€ë¡œ ê¸°ë¡ë˜ê³ ìˆìŠµë‹ˆë‹¤.')
        SQLITE.res(message1.content, 1, message1.author)
    if text == 'íšŒì˜ì‹œì‘':
        a.item = 1
        print('íšŒì˜ì‹œì‘ì¤‘ì…ë‹ˆë‹¤')






#ê²½ë§ˆ í•¨ìˆ˜
async def race(message):
    players = message.content.split()[1:]

    if len(players) < 2:
        await message.channel.send("2ëª… ì´ìƒì˜ í”Œë ˆì´ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return

    await message.channel.send("ê²½ë§ˆë¥¼ ì‹œì‘í•©ë‹ˆë‹¤!")

    distance = 20  # ê²½ì£¼ ê±°ë¦¬
    positions = {player: 0 for player in players}  # í”Œë ˆì´ì–´ì˜ í˜„ì¬ ìœ„ì¹˜

    while True:
        for player in players:
            # ê° í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸
            positions[player] += random.randint(1, 3)

            # í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ê°€ ê²½ì£¼ ê±°ë¦¬ë¥¼ ë„˜ì–´ê°€ë©´ ê²½ì£¼ê°€ ëë‚¨
            if positions[player] >= distance:
                await message.channel.send(f"{player}ê°€ ê²½ì£¼ì—ì„œ ìš°ìŠ¹í–ˆìŠµë‹ˆë‹¤!")
                return

        # ê²½ì£¼ ìƒí™©ì„ ì—…ë°ì´íŠ¸í•˜ì—¬ ì±„ë„ì— í‘œì‹œ
        race_status = ""
        for player, position in positions.items():
            progress = "ğŸ" * position + "-" * (distance - position)
            race_status += f"{player}: {progress}\n"

        await message.channel.send(race_status)

        await asyncio.sleep(1)




client.run(Discord_key)