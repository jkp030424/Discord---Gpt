# -*- coding: utf-8 -*-
"""디스코드 봇 코드

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zn1Rizx14A4Ma2mf40QbpMcT7SUEtXrh
"""



import discord
import os
import openai
import re
from discord import app_commands
from discord.ext import commands

import time
import datetime

import random
import asyncio

import sqlite3

# db, 대화관련 함수, 디스코드 명령어는 밑에 추가해둠
class Nod:
    def __init__(self, item):
        self.item = item

a = Nod(1) #대화받을떄, a.item이 1이면 회의시작, 0이면 회의종료함. 여러가지 시도해봤는데 이게 가장확실함..


def connection(a):
    # a = #파일이름
    try:
        con = sqlite3.connect(f'{os.getcwd()}/{a}.db') #여기에서 파일 경로만 넣어준다면 원하는 위치에 생성할수있음 (**경로**/파일명.db) 이런식, 경로설정은 아직 결정안함
        return con
    except:
        pass

def create_table(con):#환경설정, 여기서 날짜 설정이 기본적으로 들어감. 날짜가 테이블이름에 적힘
    cusor_db = con.cursor()
    cusor_db.execute(f'CREATE TABLE 대화_테이블(id TEXT, name TEXT, input_data TEXT, date TEXT )')
    con.commit()

def insert_one(con, one_data): # 삽입
    cusor_db = con.cursor()
    cusor_db.execute(
        'INSERT INTO 대화_테이블 VALUES (?, ?, ?, ?)',
        one_data
    )
    # 테이블을 더 늘리고싶다면  ? 추가
    con.commit()

def receive_discord(message,i, Username):
    name = '디스코드테스트' # 파일이름 고정은 나중에 수정.
    con = connection(name)
    try:
        create_table(con)  # 필수, 테이블 만들기
    except:
        pass
    data = message
    user = Username
    x = dt.datetime.now()
    date = f'{x.hour}시 {x.minute}분 {x.second}초'
    one_data = (i, str(user), str(data), date)  # 저장형식
    insert_one(con, one_data)  # 대화데이터 저장

#

intents = discord.Intents.default()
intents.message_content = True

client = discord.Client(intents = intents)
bot = commands.Bot(command_prefix='!',intents = intents)






openai.api_key = openai_key

@client.event
async def on_ready(): #실행 준비가 되면 준비가 됨을 표시
    print('We have logged in as {0.user}'.format(client))

@bot.event
async def on_connect():
    if bot.auto_sync_commands:
        await bot.sync_commands()
    print(f"{bot.user.name} connected.")


def create_image_embed(title: str, description: str, url: str):
    embed = discord.Embed(
        title=title,
        description=description,
    )
    embed.set_thumbnail(url=url)
    embed.set_image(url=url)
    return embed



@client.event
async def on_message(message):  #메세지 확인
    if message.author == client.user:   #메시지를 보낸 사람이 봇이면 빠져나오기
        return
    text = message.content

    if text.startswith('image/'):    #특정 메시지를 보냈을 때 반응
        prompt = text[6:]
        translate = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt + "Please translate the previous sentence into English and only print out the translated answer",
            max_tokens=500,
            temperature=0
        )
        print("Image prompt:", prompt)
        response = openai.Image.create(
            prompt='\n'.join([choice.text for choice in translate.choices]),
            n=1,
            size="256x256"
        )
        print(response)
        data: list = response['data']
        for index, image in enumerate(data):
            title = f"Image generated #{index + 1}"
            embed = create_image_embed(title, prompt, image['url'])
            await message.channel.send('', embed=embed)
        await message.channel.send(prompt)

    if text.startswith('vote/'):
        prompt = text[5:]
        vote_txt=prompt.split("/")
        await message.channel.send(vote_txt[0])
        for i in range(1,len(vote_txt)):
            choose = await message.channel.send(vote_txt[i])
            await choose.add_reaction('👍')


    if text.startswith('ask/'):    #특정 메시지를 보냈을 때 반응
        prompt = text[4:]
        bot_response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            max_tokens=500,
            temperature=0
        )
        print('bot response:', bot_response)
        print(message.author)
        bot_text = '\n'.join([choice.text for choice in bot_response.choices])
        await message.channel.send(bot_text)


    if text.startswith('alarm/'):  #알림 기능
        prompt = text[6:]
        time_lst = list(prompt.split("/"))            #time_lst는 시간을 담는 리스트
        date=datetime.datetime(int(time_lst[0]),int(time_lst[1]),int(time_lst[2]),int(time_lst[3]),int(time_lst[4]))

        while True:
            curr_t = datetime.datetime.now()
            if date <= curr_t:
                bot_text = "<"+str(date)+">"
                await message.channel.send(bot_text)
                bot_text = "\"" + time_lst[-1] + "\"의 내용이 예약 되어 있습니다."
                await message.channel.send(bot_text)
                break
            time.sleep(1)

    #경마기능
    if message.content.startswith('!race'):
        await race(message)



    # 회의대화 받기
    if text == '회의종료':
        a.item = 0
        print('회의 종료중이에요')
    if a.item == 1:
        print('제대로 기록되고있습니다.')
        SQLITE.res(message1.content, 1, message1.author)
    if text == '회의시작':
        a.item = 1
        print('회의시작중입니다')






#경마 함수
async def race(message):
    players = message.content.split()[1:]

    if len(players) < 2:
        await message.channel.send("2명 이상의 플레이어가 필요합니다.")
        return

    await message.channel.send("경마를 시작합니다!")

    distance = 20  # 경주 거리
    positions = {player: 0 for player in players}  # 플레이어의 현재 위치

    while True:
        for player in players:
            # 각 플레이어의 위치를 업데이트
            positions[player] += random.randint(1, 3)

            # 플레이어의 위치가 경주 거리를 넘어가면 경주가 끝남
            if positions[player] >= distance:
                await message.channel.send(f"{player}가 경주에서 우승했습니다!")
                return

        # 경주 상황을 업데이트하여 채널에 표시
        race_status = ""
        for player, position in positions.items():
            progress = "🐎" * position + "-" * (distance - position)
            race_status += f"{player}: {progress}\n"

        await message.channel.send(race_status)

        await asyncio.sleep(1)




client.run(Discord_key)